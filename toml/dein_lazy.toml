# theme =======================================================================

[[plugins]]
repo = 'yash268925/iceberg.vim'
on_event = 'VimEnter'
hook_source = '''
  colorscheme iceberg
  set termguicolors
  set cursorline
'''

# input method ================================================================

[[plugins]]
repo = 'vim-skk/skkeleton'
on_event = 'InsertEnter'
hook_add = '''
  imap <C-j> <Plug>(skkeleton-toggle)
  cmap <C-j> <Plug>(skkeleton-toggle)

  lua << EOF
  local prev_buffer_config

  function _G.skkeleton_enable_pre()
    prev_buffer_config = vim.fn['ddc#custom#get_buffer']()
    vim.fn['ddc#custom#patch_buffer']{
      completionMenu = 'native',
      sources = {'skkeleton'},
    }
  end

  function _G.skkeleton_disable_pre()
    vim.fn['ddc#custom#set_buffer'](prev_buffer_config)
  end

  vim.cmd[[
    augroup skkeleton_callbacks
      autocmd!
      autocmd User skkeleton-enable-pre call v:lua.skkeleton_enable_pre()
      autocmd User skkeleton-disable-pre call v:lua.skkeleton_disable_pre()
    augroup END
  ]]
EOF
'''
hook_source = '''
  call skkeleton#config({
    \ 'eggLikeNewline': v:true,
    \ 'globalJisyo': $HOME . '/.skk/SKK-JISYO.L',
    \ 'immediatelyJisyoRW': v:true,
    \ 'registerConvertResult': v:true,
    \ 'userJisyo': $HOME . '/.skk/userJisyo',
    \ })

'''

# status =======================================================================

[[plugins]]
repo = 'itchyny/lightline.vim'
on_event = 'UIEnter'
depends = ['iceberg.vim', 'vim-devicons', 'lightline-bufferline']
hook_add = '''
  let g:lightline = {
    \ 'colorscheme': 'iceberg',
    \ 'tabline': {
    \   'left': [[ 'buffers' ]],
    \   'right': [],
    \ },
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
    \ },
    \ 'component_function': {
    \   'gitbranch': 'FugitiveHead',
    \   'bufferinfo': 'lightline#buffer#bufferinfo',
    \ },
    \ 'component_expand': {
    \    'buffers': 'lightline#bufferline#buffers'
    \ },
    \ 'component_type': {
    \    'buffers': 'tabsel'
    \ }
    \ }
  set hidden
  set showtabline=2

  nnoremap <Left> :bprev<CR>
  nnoremap <Right> :bnext<CR>
'''

[[plugins]]
repo = 'mengelbrecht/lightline-bufferline'
hook_add = '''
  let g:lightline#bufferline#show_number=1
  let g:lightline#bufferline#enable_devicons=1
  let g:lightline#bufferline#unicode_symbols=1
  let g:lightline#bufferline#filter_by_tabpage=1
  let g:lightline#bufferline#unnamed='[No Name]'
'''

# buffer =======================================================================

[[plugins]]
repo = 'jlanzarotta/bufexplorer'
on_cmd = ['BufExplorer']

[[plugins]]
repo = 'mhinz/vim-sayonara'
on_cmd = ['Sayonara']
hook_add = '''
  nnoremap sa :<C-u>Sayonara<CR>
  nnoremap sq :<C-u>Sayonara!<CR>

  let g:sayonara_confirm_quit=1
'''

# utils ========================================================================

[[plugins]]
repo = 'lambdalisue/guise.vim'
depends = 'denops.vim'
on_source = 'neoterm'

# [[plugins]]
# repo = 'gelguy/wilder.nvim'
# depends = 'impatient.nvim'
# on_event = 'CmdlineEnter'
# hook_source = '''
#   silent! call wilder#enable_cmdline_enter()
#   set wildcharm=<Tab>
# 
#   cnoremap <expr> <Tab> wilder#in_context() ? wilder#next() : "\<Tab>"
#   cnoremap <expr> <S-Tab> wilder#in_context() ? wilder#previous() : "\<S-Tab>"
# 
#   " only / and ? are enabled by default
#   call wilder#set_option('modes', ['/', '?', ':'])
# 
#   " When the cmdline is empty, provide suggestions based on the cmdline history
#   call wilder#set_option('pipeline', [
#     \   wilder#branch(
#     \     [
#     \       wilder#check({_, x -> empty(x)}),
#     \       wilder#history(),
#     \     ],
#     \     wilder#cmdline_pipeline(),
#     \     wilder#search_pipeline(),
#     \   ),
#     \ ])
# 
#   " popupmenu completion
#   call wilder#set_option('renderer', wilder#popupmenu_renderer({
#     \ 'highlighter': wilder#basic_highlighter(),
#     \ }))
# '''

[[plugins]]
repo = 'kassio/neoterm'
on_event = 'CmdlineEnter'

[[plugins]]
repo = 'ojroques/vim-oscyank'
on_if = '$SSH_CONNECTION != ""'
hook_add = '''
  let g:oscyank_term = 'kitty'
  autocmd TextYankPost * if v:event.operator is 'y' && v:event.regname is '+' | OSCYankReg + | endif
'''

# git ==========================================================================

[[plugins]]
repo = 'cohama/agit.vim'
on_cmd = ['Agit']
hook_add = '''
  autocmd FileType agit call s:agit_keymaps()

  function! s:agit_keymaps()
    nmap <buffer> R <Plug>(agit-reload)
  endfunction
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_event = 'BufFilePre'

[[plugins]]
repo = 'rhysd/conflict-marker.vim'
on_event = 'BufFilePre'

[[plugins]]
repo = 'tpope/vim-fugitive'
on_event = 'CmdLineEnter'
hook_add = '''
  autocmd FileType fugitivestatus nmap <buffer> q gq
'''

# coding support ===============================================================

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
on_event = 'BufFilePre'
